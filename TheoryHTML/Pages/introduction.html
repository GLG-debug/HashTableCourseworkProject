<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Страница 1</title>
  </head>
  <body>
    <p style="text-align: center">
      <i><b>Страница 1</b></i>
    </p>
    <hr />
    <h1 style="text-align: center">Введение</h1>
    <h2 style="text-align: center">Гардероб [3, с. 393-394]</h2>
    <p style="text-align: justify">
      Когда вы сдаете в гардероб пальто или сумку, вам выдают номерок. Когда же
      вы собираетесь покинуть помещение, вы отдаете номерок, и вам возвращают
      ваше пальто или сумку.
    </p>
    <p style="text-align: justify">
      Если вдуматься, какую задачку решает данный процесс, можно увидеть, что
      это задача о поиске и нахождении объекта. Ваше пальто &mdash; это объект,
      который вы передаете гардеробщику; пальто сначала привязывают к
      определенному номерку, а затем возвращают вам. Метод работает за счет
      того, что в гардеробе находятся ряды пронумерованных вешалок для одежды и
      пронумерованные отделения для сумок. Вашему номерку соответствует
      определенная вешалка или определенное отделение. Гардеробщик же отвечает
      за то, чтобы разместить ваш объект в нужном месте и чтобы забрать его с
      помощью отданного вами номерка.
    </p>
    <p style="text-align: justify">
      Когда речь идет о поиске, люди чаще всего представляют себе, что нужно
      перебирать вещи до тех пор, пока не найдется нужная; процесс становится
      проще, если вещи отсортированы так, что мы можем искать среди них более
      слаженно. Гардероб же показывает, что есть и другой способ: присвоить вещи
      адрес, где она будет располагаться, и затем сразу достать ее из указанного
      места. В гардеробе адрес указан на номерках, и гардеробщик на самом деле
      ищет не ваши вещи: он смотрит на номерок, на адрес и идет к указанной
      вешалке или отделению с вашими вещами.
    </p>
    <p style="text-align: justify">
      Весь метод в целом можно назвать определением местонахождения
      <i>без поиска</i>: мы не ищем объект, а получаем адрес места, где он будет
      храниться. Соотносим объект с адресом, а затем, когда хотим найти объект,
      мы идем прямиком к нужному месту.
    </p>
    <p style="text-align: justify">
      Теперь рассмотрим данный метод с точки зрения компьютерного мира, где наши
      объекты представлены в виде записей, содержащих атрибуты. Мы хотим уметь
      переходить напрямую от&nbsp;записи к адресу, по которому она размещена;
      адресом будет число, соответствующее области в компьютерной памяти.
      Главная загвоздка в такой задачке &mdash; то, как соотнести адрес с
      элементом. Нам нужен быстрый и надежный способ, и мы не можем положиться
      на какого-либо посредника. Когда мы ищем запись, мы ищем ее по одному или
      большему числу атрибутов, которые формируют ключ записи, поэтому нам нужен
      метод получения адреса из ключа записи. Так как адрес &mdash; это число,
      нам нужен способ, который перенесет нас от ключей к числам. Иными словами,
      мы нуждаемся в функции, скажем, <i>f(K)</i>, которая возьмет ключ K записи
      R и вернет значение <i>a = f(K)</i>. Значение a представляет собой адрес,
      где будет храниться запись, мы идем по нему и оставляем там нашу запись.
      Каждый раз, когда нам требуется достать нашу запись с помощью ключа, мы
      снова прибегаем к функции <i>f(K)</i>, которая вернет то же адресное
      значение a, откуда мы и заберем нашу запись. Функция должна быть быстрой и
      достаточно скоро находить нужный адрес: как минимум, не дольше, чем поиск
      по записям до тех пор, пока не найдется та, которую мы ищем. В противном
      случае толку от такой функции никакого. Если же мы в самом деле
      обзаведемся такой функцией, то разрешим нашу задачку с местоположением
      новым способом: не мы будем искать элемент, а сам элемент расскажет нам,
      где его найти: расскажет с помощью нашей функции.
    </p>
    <h2 style="text-align: center">Продавец</h2>
    <p style="text-align: justify">
      Так же стоит привести введение в теоретический материал, описанное автором
      книги [1, c. 100-101], где описывается пример с &quot;продавцом в
      маленьком магазинчике&quot;.
    </p>
    <p style="text-align: justify">
      В ситуации, когда клиент покупает
      у&nbsp;продавца&nbsp;товар&nbsp;необходимо определить ценность предмета.
      Изначально стоит отметить, что цены в магазинах на один и тот же товар
      всегда одинаковый в один момент времени, поэтому необходимо хранить
      информацию о ценах, например, в книге, однако данный метод оперирования
      информацией будет весьма утомителен и ужасно&nbsp;неэффективен. Для
      решения этой проблемы&nbsp;продавец&nbsp;нанимает помощницу, которая
      безошибочно определяет цену на товар, если посмотрит на него или узнает
      его название.
    </p>
    <p style="text-align: justify">
      Автор абстрактно описывает проблему с упорядоченным контейнером данных,
      где может потребоваться простой поиск, алгоритм которого обладает линейной
      сложностью. В данном примере контейнер является хранилищем элементов,
      каждый из которых может повторяться, но обязан иметь только один
      уникальный идентификатор. Можно с уверенностью выделить две проблемы, от
      которых можно избавиться в <i>идеальных </i>условиях &mdash; затраты на
      хранение элементов и поиск каждого из них при помощи уникального
      идентификатора. В приоритете необходимо выполнять успешный поиск элемента,
      алгоритм которого будет выполняться за константное время.
    </p>
    <p style="text-align: justify">
      Решением является использование функции [4, c. 96] из множества <i>A</i> в
      множество <i>B.</i>&nbsp;Данная функция описывает бинарное отношение, при
      котором <i>каждый</i>&nbsp;элемент множества <i>А</i> связан с
      единственным элементом множества <i>B</i>.&nbsp; Данная функция в
      программировании имеет название хеш-функция. Избавиться от необходимости в
      хранении множеств элементов, чтобы сохранялась возможность определять
      новые бинарные отношения, не изменяя другие очень сложно, однако это
      возможно. Обычно, когда известны все элементы множества <i>А</i> и все
      элементы множества <i>B</i>, реализуют функцию, при которой любой элемент
      множества <i>А</i> имеет одно отношение с любым элементом из множества
      <i>B</i>. Например, данную функцию можно применить в примере с продавцом и
      помощницей, если каталог товаров не изменяется, но цены на разные товары
      могут совпадать.
    </p>
  </body>
</html>
